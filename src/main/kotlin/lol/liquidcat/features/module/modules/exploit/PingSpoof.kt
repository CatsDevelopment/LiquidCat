/*
 * LiquidCat Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CatsDevelopment/LiquidCat
 */
package lol.liquidcat.features.module.modules.exploit

import lol.liquidcat.event.EventTarget
import lol.liquidcat.event.PacketEvent
import lol.liquidcat.event.UpdateEvent
import lol.liquidcat.features.module.Module
import lol.liquidcat.features.module.ModuleCategory
import lol.liquidcat.value.IntegerValue
import net.ccbluex.liquidbounce.utils.timer.TimeUtils
import net.minecraft.network.Packet
import net.minecraft.network.play.client.C00PacketKeepAlive

class PingSpoof : Module("PingSpoof", "Spoofs your ping to a given value.", ModuleCategory.EXPLOIT) {

    private val maxDelayValue: IntegerValue = object : IntegerValue("MaxDelay", 1000, 0, 5000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val minDelayValue = minDelayValue.get()
            if (minDelayValue > newValue) set(minDelayValue)
        }
    }

    private val minDelayValue: IntegerValue = object : IntegerValue("MinDelay", 500, 0, 5000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val maxDelayValue = maxDelayValue.get()
            if (maxDelayValue < newValue) set(maxDelayValue)
        }
    }

    private val packets = hashMapOf<Packet<*>, Long>()

    override fun onDisable() {
        packets.clear()
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet

        if (packet is C00PacketKeepAlive && !packets.containsKey(packet) && !mc.thePlayer.isDead) {
            event.cancelEvent()

            synchronized(packets) {
                packets.put(
                    packet,
                    System.currentTimeMillis() + TimeUtils.randomDelay(minDelayValue.get(), maxDelayValue.get())
                )
            }
        }
    }

    @EventTarget(ignoreCondition = true)
    fun onUpdate(event: UpdateEvent) {
        try {
            var filteredPackets: List<Packet<*>>

            synchronized(packets) {
                filteredPackets = packets.entries
                    .filter { it.value <= System.currentTimeMillis() }
                    .map { it.key }
            }

            for (packet in filteredPackets) {
                mc.netHandler.addToSendQueue(packet)
                packets.remove(packet)
            }

        } catch (e: Throwable) {
            e.printStackTrace()
        }
    }
}